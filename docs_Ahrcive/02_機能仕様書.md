# MySisterDB 機能仕様書

## 目次
1. [会話履歴HTMLテキスト抽出機能](#会話履歴htmlテキスト抽出機能)
2. [認証機能付きプラットフォーム機能](#認証機能付きプラットフォーム機能)
3. [GitHub Copilot開発会話学習システム](#github-copilot開発会話学習システム)

---

## 会話履歴HTMLテキスト抽出機能

### 1. 背景・目的
- Google Geminiのウェブページから保存したHTMLファイルから、純粋な会話履歴テキストを抽出し、`conversation_summary_tool.py` の入力として活用する。  
- ユーザー利便性向上とAI学習データの質向上を図る。

### 2. 機能概要
| 機能名                   | HtmlConversationExtractor                                                          |
|--------------------------|-------------------------------------------------------------------------------------|
| 入力                     | HTMLファイル（.html/.htm）                                                          |
| 出力                     | 抽出済み会話テキスト（`str`）                                                       |
| 使用ライブラリ           | BeautifulSoup4、chardet（任意）                                                     |
| 文字コード               | UTF-8推奨（メタタグ、自動検出フォールバック）                                       |

### 3. 主な処理フロー

1. **ファイル読み込み**  
   - 存在チェック + サイズ上限チェック  
   - エンコーディング検出（UTF-8優先、`chardet`で自動判別）  
2. **HTMLパース**  
   - BeautifulSoupでDOM生成  
3. **会話ブロック抽出**  
   - 設定ファイル（または定数）に定義したCSSセレクタで該当要素を検索  
   - 複数パターン（`message-container`, `message-bubble`など）に対応  
4. **テキスト抽出＆整形**  
   - タグ削除＋空行トリミング  
   - 発言者ラベル付与（`ユーザー:`, `Gemini:`）  
   - タイムスタンプ等のOptionalメタ情報抽出（オプション実装）  
5. **エラーハンドリング**  
   - ファイル未発見、パース失敗、マッチ要素なしそれぞれに対応  
   - 詳細ログ（`logging`）出力と空文字列返却  
6. **呼び出し例**  
   ```python
   from html_extractor import extract_gemini_conversation_from_html

   text = extract_gemini_conversation_from_html('history.html')
   if not text:
       logging.error('抽出失敗')
   ```

### 4. テストケース
- **正常系**  
  - 標準的なGemini HTMLから全発言を正確に抽出  
  - ユーザー⇔Geminiの識別とラベル付与  
- **異常系**  
  - 存在しないファイルパス → 空文字＆エラーログ  
  - HTML構造変化（セレクタ不一致） → 可能な限りテキスト抽出 or 空文字  
  - 非UTF-8ファイル → 自動判別で復旧 or エラーハンドリング  

### 5. 拡張性・運用上の懸念
- **HTML構造変動**: CSSセレクタを設定ファイル化し、定期メンテナンスを実施  
- **動的生成コンテンツ**: 必要に応じてHeadlessブラウザ（Playwright）でレンダリング  
- **パフォーマンス**: 大容量ファイルはチャンク分割 or ストリーミング解析  
- **セキュリティ**: スクリプト除去・サイズ検査で安全性確保  
- **ログ/診断**: `logging`で詳細情報を残し、原因特定を容易に

### 6. 実装ファイル・配置
```
MySisterDB/
├── html_extractor_spec.md          # 本仕様書
├── extractor/                      # 新規モジュール
│   └── html_extractor.py           # 実装ファイル
└── conversation_summary_tool.py    # 呼び出しを追加
```

### 7. ワークフロー
1. `pip install beautifulsoup4 chardet`
2. `html_extractor_spec.md` で仕様確認  
3. `extractor/html_extractor.py` を作成  
4. テストケース実装＆`pytest`実行  
5. `conversation_summary_tool.py` に統合・メニュー追加  
6. CI（GitHub Actions等）で品質チェック  

**参照元:** `html_conversation_extractor_spec.md`

---

## 認証機能付きプラットフォーム機能

### A. マネージド認証＋サーバーレスプラットフォーム

1. **AWS Amplify + Cognito + Lambda**
   - パスワード認証、SNS ログインを標準サポート
   - ユーザープロファイル属性や多要素認証を簡単設定
   - Amplify SDK でフロント連携が容易

★2. **Firebase Hosting + Firebase Auth + Cloud Functions**
   - メール認証／SNS ログインを数行で導入
   - Firestore に学習データ保存可能
   - 無料枠が大きくプロトタイピング向き

3. **Supabase + Edge Functions**
   - PostgreSQL＋Auth（GoTrue）＋Row Level Security
   - 認証済みユーザー限定 API 実装に最適
   - UI 管理コンソールが充実

### B. セルフホスティング／コンテナ構成

1. **FastAPI + OAuth2 / OpenID Connect**
   - Auth0 や Okta との連携が容易
   - Pydantic モデル + OpenAPI 自動生成
   - JWT で認証トークン管理

2. **NestJS + Passport.js + Keycloak**
   - セルフホスト or マネージド Keycloak で SSO/CASB
   - Role／Permission の細かな制御
   - Docker Compose で Keycloak＋NestJS＋PostgreSQL

### C. フロント統合例

- **Next.js + NextAuth.js**
  - Vercel との相性抜群、SSR/ISR と API 連携可能
  - Cognito/Auth0/Firebase/Supabase 対応

- **Nuxt 3 + Nuxt Auth**
  - Vue エコシステム向け認証モジュール

### 選定ポイント

1. **運用負荷**: マネージドサービス (Amplify/Firebase/Supabase) は運用楽
2. **拡張性**: セルフホスト (FastAPI/NestJS) は細かい権限制御に強い
3. **コスト**: 無料枠活用／商用 Traffic 見込みで選択
4. **チームスキル**: Python 中心なら FastAPI、JS 中心なら NestJS

**参照元:** `deployment_auth_platforms.md`

---

## GitHub Copilot開発会話学習システム

### 1. 開発会話学習の目的
- **開発効率向上**: 過去の解決パターンを活用した迅速な問題解決
- **知識継承**: 開発過程で得られた技術的知見の蓄積
- **品質向上**: 過去のバグパターンから予防策を提案
- **学習促進**: 新しい技術習得時の参考情報提供

### 2. 学習対象となる開発会話カテゴリ
#### A. 実装フェーズ
- 新機能開発の相談・実装
- アルゴリズム・データ構造の選択
- フレームワーク・ライブラリの使用方法
- コード最適化・リファクタリング

#### B. デバッグ・トラブルシュート
- エラー解析・原因特定
- バグ修正手順・パターン
- パフォーマンス問題の解決
- 環境設定・依存関係の問題

#### C. コードレビュー・改善
- コード品質向上の提案
- セキュリティ脆弱性の指摘
- 保守性向上のためのリファクタリング
- ベストプラクティスの適用

#### D. 設計・アーキテクチャ
- システム設計の相談
- データベース設計の検討
- API設計・インターフェース定義
- 技術選定の判断根拠

### 3. 開発会話データ構造

```python
DevelopmentConversation = {
    "conversation_id": str,
    "timestamp": datetime,
    "category": str,              # implementation/debug/review/design
    "technology_stack": List[str], # Python, Flask, ChromaDB等
    "problem_description": str,    # 解決しようとした問題
    "solution_approach": str,      # 採用したアプローチ
    "code_snippets": List[dict],   # 関連コードスニペット
    "file_paths": List[str],       # 関連ファイルパス
    "success_metrics": dict,       # 成功指標（実行時間、エラー率等）
    "lessons_learned": str,        # 学んだ教訓・注意点
    "related_issues": List[str],   # 関連する過去の問題
    "tags": List[str]             # 検索用タグ
}
```

### 4. 開発会話キャプチャシステム
```python
# utils/dev_conversation_capture.py
class DevConversationCapture:
    def capture_conversation(self, user_input: str, assistant_response: str, 
                           session_context: Dict) -> Dict:
        """開発会話を構造化してキャプチャ"""
        
        # 会話タイプの判定
        conversation_type = self._classify_conversation_type(user_input)
        
        # 技術スタックの抽出
        tech_stack = self._extract_technology_stack(user_input + " " + assistant_response)
        
        # コードスニペットの抽出
        code_snippets = self._extract_code_snippets(assistant_response)
        
        # ファイルパスの抽出
        file_paths = self._extract_file_paths(user_input + " " + assistant_response)
        
        # 問題と解決策の抽出
        problem_solution = self._extract_problem_solution(user_input, assistant_response)
        
        return {
            "conversation_id": session_context.get("conversation_id"),
            "timestamp": datetime.now(),
            "category": conversation_type,
            "technology_stack": tech_stack,
            "problem_description": problem_solution["problem"],
            "solution_approach": problem_solution["solution"],
            "code_snippets": code_snippets,
            "file_paths": file_paths,
            "user_input": user_input,
            "assistant_response": assistant_response,
            "tags": self._generate_tags(user_input, assistant_response, tech_stack)
        }
```

### 5. 開発作業記録方式の採用
**アプローチ**:
```
開発作業中の学習 → 簡単記録 → 自動構造化 → MySisterDB連携
```

**最小限アーキテクチャ**:
```
TextSystemFromAssistanTalk/
├── core/
│   ├── session_recorder.py      # 作業セッション記録
│   ├── learning_extractor.py    # 学習内容抽出
│   └── mysisterdb_connector.py  # MySisterDB連携
├── input/
│   ├── daily_log.md            # 日次作業ログ
│   └── session_notes.txt       # セッションメモ
├── output/
│   └── generated_data/         # 生成データ
└── simple_main.py             # 超シンプルメイン
```

**期待される効果**:
- 日々の開発知識の確実な蓄積
- 問題解決パターンのデータベース化
- MySisterDBの知識ベース強化
- 過去の解決策の効率的な検索・活用
- 開発効率の向上

**参照元:** `Advice_GakusyuFromCopilot.md`, `conversation_improvement_operations.md`
