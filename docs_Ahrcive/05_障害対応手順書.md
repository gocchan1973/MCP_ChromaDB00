# MySisterDB 障害対応手順書

## 緊急サーバー停止手順

### 症状: サーバーフリーズ・応答なし
サーバープロセスが応答しなくなり、`Ctrl+C`による通常の停止が機能しない状態。

### 対応手順

#### 1. プロセスID (PID) の特定

**Windows環境の場合:**
```powershell
# PowerShellで実行
Get-Process -Name python | Where-Object {$_.CommandLine -like "*main.py*"}
# または
tasklist | findstr python
```

**出力例:**
```
python.exe                   1234 Console                    1     123,456 K
python.exe                   5678 Console                    1     234,567 K
```

**プロセス特定方法:**
上記の出力例から、`python.exe`に関連するプロセスID (PID) を確認します。この例では、`1234`や`5678`がPIDです。

**Linux/macOS環境の場合:**
```bash
ps aux | grep "main.py"
# または
lsof -i :8000  # サーバーポート番号を指定
```

#### 2. プロセスの強制終了

**Windows環境の場合:**
```powershell
# PowerShellで実行（PIDを指定）
taskkill /F /PID <プロセスID>
# 例: taskkill /F /PID 106228

# または
Stop-Process -Id <プロセスID> -Force
```

**プロセスID確認と強制終了の詳細例:**
```powershell
# プロセスIDの確認
Get-Process -Name python | Where-Object {$_.CommandLine -like "*main.py*"}

# 強制終了の実行（例: PIDが1234の場合）
taskkill /F /PID 1234
```

**Linux/macOS環境の場合:**
```bash
kill -9 <プロセスID>
```

#### 3. リソース状況の確認

**Windows環境の場合:**
```powershell
# メモリ使用状況
Get-Process | Sort-Object -Property WS -Descending | Select-Object -First 10
```

**Linux環境の場合:**
```bash
# メモリ使用状況
free -h
# ディスク使用状況
df -h
```

#### 4. ログの保存
```bash
# フリーズ発生時のログを別名で保存
copy logs\mysisterdb.log logs\mysisterdb_freeze_$(date +%Y%m%d_%H%M%S).log
```

### リカバリー手順

#### 1. データベース整合性確認
```bash
python utils/consistency_check.py
```

#### 2. サービス再起動
```bash
cd web_local
python -m uvicorn main:app --reload
# または
python main.py
```

#### 3. ヘルスチェック
```bash
curl http://localhost:8000/api/health
# または
curl http://localhost:8000/api/current-time
```

## 根本原因分析と防止策

### 考えられる原因

1. **無限ループ**: ユーザーからの特定入力パターンでコード内に無限ループが発生
2. **メモリリーク**: 長時間実行でメモリが徐々に枯渇
3. **デッドロック**: 複数のスレッド/プロセス間のロック取得の矛盾
4. **リソース競合**: ファイルやDB接続の競合状態
5. **外部API遅延**: Gemini APIからの応答待ちでタイムアウト設定なし
6. **会話コンテキスト拡大**: 過去の話題参照時に会話履歴が肥大化し処理時間が増大

### 防止策

#### 1. タイムアウト設定の追加
```python
# Gemini API呼び出しにタイムアウト設定を追加
import asyncio
from asyncio import TimeoutError

async def call_gemini_api_with_timeout(prompt_text, timeout=30):
    try:
        response = await asyncio.wait_for(
            model.generate_content_async(prompt_text),
            timeout=timeout
        )
        return response.text
    except TimeoutError:
        return "応答生成がタイムアウトしました。もう一度試してください。"
    except Exception as e:
        return f"エラーが発生しました: {str(e)}"
```

#### 2. リソース監視の実装
```python
# メモリ使用量の監視とログ出力
import psutil
import os

def log_resource_usage():
    process = psutil.Process(os.getpid())
    memory_info = process.memory_info()
    
    logging.info(f"メモリ使用量: {memory_info.rss / 1024 / 1024:.2f} MB")
    logging.info(f"CPU使用率: {process.cpu_percent()}%")
    
    if memory_info.rss > 500 * 1024 * 1024:  # 500MB以上
        logging.warning("メモリ使用量が高いです！")
```

#### 3. ウォッチドッグタイマーの実装
```python
# リクエスト処理に最大時間制限を設けるミドルウェア
@app.middleware("http")
async def request_timeout_middleware(request: Request, call_next):
    try:
        return await asyncio.wait_for(call_next(request), timeout=60.0)
    except asyncio.TimeoutError:
        return JSONResponse(
            status_code=504,
            content={"error": "Request processing timed out"}
        )
```

#### 4. 自動再起動システム
```python
# 監視スクリプト（別プロセスで実行）
def monitor_and_restart():
    while True:
        try:
            response = requests.get("http://localhost:8000/api/health", timeout=5)
            if response.status_code != 200:
                restart_server()
        except:
            restart_server()
        time.sleep(60)  # 1分ごとに確認
```

#### 5. ログ強化
詳細なログを有効にし、異常検知の手がかりを増やす。

```python
# より詳細なログ設定
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("logs/mysisterdb_detailed.log"),
        logging.StreamHandler()
    ]
)
```

#### 6. 会話コンテキスト管理の最適化
```python
# 会話コンテキスト量を制限し、過去の話題参照によるタイムアウトを防止
def optimize_conversation_context(conversation_history):
    # 1. 最大トークン数の制限
    MAX_TOKENS = 4000
    current_tokens = count_tokens(conversation_history)
    
    if current_tokens > MAX_TOKENS:
        # 古い会話から削減、ただし直近の会話は保持
        conversation_history = trim_conversation_history(
            conversation_history, 
            target_tokens=MAX_TOKENS,
            preserve_recent=3  # 直近3つの対話は保持
        )
    
    # 2. 関連性の低いコンテキストを除外
    relevance_scores = score_context_relevance(conversation_history)
    conversation_history = filter_by_relevance(
        conversation_history,
        relevance_scores,
        threshold=0.4  # 関連性スコア閾値
    )
    
    return conversation_history
```

## フリーズ事例収集

| 発生日時 | 発生状況 | 入力内容 | 根本原因 | 解決策 |
|---------|---------|---------|---------|-------|
| 2025-06-02 21:42 | API Query | "枡元といえば？ｗ" | 調査中 | - |
| 2025-06-02 | 過去の話題参照 | 過去の話題に言及する質問 | 会話コンテキスト肥大化による処理遅延 | コンテキスト制限機能の実装 |

## 特定問題対応手順

### 過去の話題参照時のタイムアウト対策

#### 症状:
- 過去の話題を参照する質問をすると応答が極端に遅延またはタイムアウト
- サーバープロセスがフリーズし制御不能になる

#### 緊急対応:
1. **タイムアウトしたプロセスの強制終了**
   ```powershell
   # プロセスID特定
   tasklist | findstr python
   # 強制終了
   taskkill /F /PID <プロセスID>
   ```

2. **一時的な対処としての会話履歴リセット**
   ```python
   # 実行中のサーバーで会話履歴をリセット
   GET http://localhost:8000/api/reset_conversation
   ```

#### 恒久対策:
1. **会話履歴サイズ制限の実装**
   - 最大トークン数の設定
   - 古い会話の要約による圧縮

2. **処理時間監視の実装**
   ```python
   import time
   import threading

   def execute_with_timeout(func, args=(), kwargs={}, timeout=30):
       """指定時間内に関数を実行、タイムアウトしたら中断"""
       result = [None]
       exception = [None]
       
       def worker():
           try:
               result[0] = func(*args, **kwargs)
           except Exception as e:
               exception[0] = e
               
       thread = threading.Thread(target=worker)
       thread.daemon = True
       thread.start()
       thread.join(timeout)
       
       if thread.is_alive():
           return {
               "error": "処理がタイムアウトしました",
               "status": "timeout"
           }
       
       if exception[0]:
           return {
               "error": str(exception[0]),
               "status": "error"
           }
           
       return {
           "result": result[0],
           "status": "success"
       }
   ```

3. **段階的レスポンス生成**
   - 即時応答の後に詳細情報を非同期で取得
   - プログレス表示によるユーザー体験向上

